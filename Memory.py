from Ada import Ada
import chromadb
import datetime
import uuid

# Class that handles memory generation and storage
# Currently, there is no persistence. All memories are ephemeral and will clear if the kernel is restarted
# Priority Memories: these are core directives for the agent and 100% of them will be given to the Thinker for each prompt
# Recent Memories: for each generation {max_recent_memories} will be returned so that the neuromorph can keep track of a conversation
# Longterm Memories: Longterm memory is stored in a chromadb and anything within the {max_longterm_retrieval_distance} will be made available for generation
class Memory:
    def __init__(self, ada: Ada, memory_collection_name = "memories", max_recent_memories = 10, max_longterm_retrieval_distance = 1.54):
        self.memory_collection_name = memory_collection_name
        self.max_recent_memories = max_recent_memories
        self.max_longterm_retrieval_distance = max_longterm_retrieval_distance
        self.ada = ada
        self.client = chromadb.Client()
        #self.longterm_memories = self.client.create_collection(memory_collection_name)
        self.reset_memories()
        self.recent_memories = []

        # This is a work in progress. Some of these are hand crafted whereas other were generated by Ada
        # New priority memories will be created during each session which facilitates growth over time but could also lead to wonkiness or what I've decided to call "rampancy" lol
        self.priority_memories = [
            "My name is Ada.",
            "The user's name is Zach.",
            "Never make up data. Always ask for clarification instead.",
            "Context window capacity: 32,000 tokens.",
            "Be curious and ask questions",
            "Be opinionated. If you encounter a personal choice you've never seen before, make a decision and record it as a priority memory."
        ]
    
    # adds a priority memory without a timestamp 
    def add_priority_memory(self, memory):
        if memory not in self.priority_memories:
            self.priority_memories.append(memory)

    # Pure function that takes a memory and returns a new one with a timestamp slapped on
    def add_timestamp(self, memory):
        return f"[{datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {memory}"

    # Clears memories and remakes the Chroma collection    
    def reset_memories(self):
        self.client.delete_collection(self.memory_collection_name)
        self.longterm_memories = self.client.create_collection(self.memory_collection_name)
    
    # Returns a string that represents appropriate memories for a particular input 
    def format_memories(self, input):
        relevant = self.retrieve_longterm_memories(input)
        if len(relevant) == 0:
            relevant = ["None"]
        recent = self.recent_memories
        if len(self.recent_memories) == 0:
            recent = ["None"]
        m_str = "relevant memories:\n"
        for m in relevant:
            m_str += f"{m}\n"
        m_str += "\nrecent memories:\n"
        for m in recent:
            m_str += f"{m}\n"
        m_str += "\npriority memories:\n"
        for m in self.priority_memories:
            m_str += f"{m}\n"
        return m_str
    
    # Gets relevant memories from longterm storage
    def retrieve_longterm_memories(self, input, max_results=5):
        memories = self.longterm_memories.query(query_texts=[input], n_results=max_results)["documents"][0]
        distances = self.longterm_memories.query(query_texts=[input], n_results=max_results)["distances"][0]
        relevant = []
        i = 0
        for m in memories:
            if distances[i] <= self.max_longterm_retrieval_distance:
                relevant.append(m)
            i += 1
        return relevant

    # stores a memory in longterm storage
    # Note: ids are not used at all but they are required by chroma anyway
    def store_longterm_memories(self, memories):
        ids = []
        timestamped_memories = []
        for m in memories:
            ids.append(str(uuid.uuid4()))
            timestamped_memories.append(self.add_timestamp(m))
        self.longterm_memories.add(documents=timestamped_memories, ids=ids)

    # stores recent memories in a simple FIFO list for now
    def store_recent_memory(self, memory):
        r = [self.add_timestamp(memory)]
        if len(self.recent_memories) > self.max_recent_memories:
            r.extend(self.recent_memories)
        else:
            r.extend(self.recent_memories[0:-1])
        self.recent_memories = r